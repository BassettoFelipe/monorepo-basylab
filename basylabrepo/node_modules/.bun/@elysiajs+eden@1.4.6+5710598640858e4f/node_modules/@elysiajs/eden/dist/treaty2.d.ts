import { InputSchema, Elysia, ELYSIA_FORM_DATA } from 'elysia';
import { P as Prettify, b as MaybeEmptyObject, a as IsNever, N as Not } from './types-BdHMTa_C.js';
import { BunFile } from 'bun';

declare class EdenWS<in out Schema extends InputSchema<any> = {}> {
    url: string;
    ws: WebSocket;
    constructor(url: string);
    send(data: Schema['body'] | Schema['body'][]): this;
    on<K extends keyof WebSocketEventMap>(type: K, listener: (event: Treaty.WSEvent<K, Schema['response'][200]>) => void, options?: boolean | AddEventListenerOptions): this;
    off<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, options?: boolean | EventListenerOptions): this;
    subscribe(onMessage: (event: Treaty.WSEvent<'message', Schema['response'][200]>) => void, options?: boolean | AddEventListenerOptions): this;
    addEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (event: Treaty.WSEvent<K, Schema['response'][200]>) => void, options?: boolean | AddEventListenerOptions): this;
    removeEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, options?: boolean | EventListenerOptions): this;
    close(): this;
}

type And<A extends boolean, B extends boolean> = A extends true ? B extends true ? true : false : false;
type ReplaceGeneratorWithAsyncGenerator<in out RecordType extends Record<string, unknown>> = {
    [K in keyof RecordType]: IsNever<RecordType[K]> extends true ? RecordType[K] : RecordType[K] extends Generator<infer A, infer B, infer C> ? void extends B ? AsyncGenerator<A, B, C> : And<IsNever<A>, void extends B ? false : true> extends true ? B : AsyncGenerator<A, B, C> | B : RecordType[K] extends AsyncGenerator<infer A, infer B, infer C> ? And<Not<IsNever<A>>, void extends B ? true : false> extends true ? AsyncGenerator<A, B, C> : And<IsNever<A>, void extends B ? false : true> extends true ? B : AsyncGenerator<A, B, C> | B : RecordType[K] extends ReadableStream<infer A> ? AsyncGenerator<A, void, unknown> : RecordType[K];
} & {};
type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N ? Acc[number] : Enumerate<N, [...Acc, Acc['length']]>;
type IntegerRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;
type SuccessCodeRange = IntegerRange<200, 300>;
type MaybeArray<T> = T | T[];
type MaybeArrayFile<T> = T extends (File | BunFile)[] ? (File | BunFile)[] | File | BunFile : T extends File | BunFile ? File | BunFile : T;
type RelaxFileArrays<T> = T extends Record<string, unknown> ? {
    [K in keyof T]: MaybeArrayFile<T[K]>;
} : T;
type SerializeQueryParams<T> = T extends Record<string, any> ? {
    [K in keyof T]: T[K] extends Date ? string : T[K] extends Date | undefined ? string | undefined : T[K];
} : T;
declare namespace Treaty {
    interface TreatyParam {
        fetch?: RequestInit;
    }
    export type Create<App extends Elysia<any, any, any, any, any, any, any>> = App extends {
        '~Routes': infer Schema extends Record<any, any>;
    } ? Prettify<Sign<Schema>> & CreateParams<Schema> : 'Please install Elysia before using Eden';
    export type Sign<in out Route extends Record<any, any>> = {
        [K in keyof Route as K extends `:${string}` ? never : K]: K extends 'subscribe' ? MaybeEmptyObject<Route['subscribe']['headers'], 'headers'> & MaybeEmptyObject<SerializeQueryParams<Route['subscribe']['query']>, 'query'> extends infer Param ? (options?: Param) => EdenWS<Route['subscribe']> : never : Route[K] extends {
            body: infer Body;
            headers: infer Headers;
            params: any;
            query: infer Query;
            response: infer Res extends Record<number, unknown>;
        } ? MaybeEmptyObject<Headers, 'headers'> & MaybeEmptyObject<SerializeQueryParams<Query>, 'query'> extends infer Param ? {} extends Param ? undefined extends Body ? K extends 'get' | 'head' ? (options?: Prettify<Param & TreatyParam>) => Promise<TreatyResponse<ReplaceGeneratorWithAsyncGenerator<Res>>> : (body?: RelaxFileArrays<Body>, options?: Prettify<Param & TreatyParam>) => Promise<TreatyResponse<ReplaceGeneratorWithAsyncGenerator<Res>>> : K extends 'get' | 'head' ? (options?: Prettify<Param & TreatyParam>) => Promise<TreatyResponse<ReplaceGeneratorWithAsyncGenerator<Res>>> : {} extends Body ? (body?: RelaxFileArrays<Body>, options?: Prettify<Param & TreatyParam>) => Promise<TreatyResponse<ReplaceGeneratorWithAsyncGenerator<Res>>> : (body: RelaxFileArrays<Body>, options?: Prettify<Param & TreatyParam>) => Promise<TreatyResponse<ReplaceGeneratorWithAsyncGenerator<Res>>> : K extends 'get' | 'head' ? (options: Prettify<Param & TreatyParam>) => Promise<TreatyResponse<ReplaceGeneratorWithAsyncGenerator<Res>>> : (body: RelaxFileArrays<Body>, options: Prettify<Param & TreatyParam>) => Promise<TreatyResponse<ReplaceGeneratorWithAsyncGenerator<Res>>> : never : CreateParams<Route[K]>;
    };
    type CreateParams<Route extends Record<string, any>> = Extract<keyof Route, `:${string}`> extends infer Path extends string ? IsNever<Path> extends true ? Prettify<Sign<Route>> : // ! DO NOT USE PRETTIFY ON THIS LINE, OTHERWISE FUNCTION CALLING WILL BE OMITTED
    (((params: {
        [param in Path extends `:${infer Param}` ? Param extends `${infer Param}?` ? Param : Param : never]: string | number;
    }) => Prettify<Sign<Route[Path]>> & CreateParams<Route[Path]>) & Prettify<Sign<Route>>) & (Path extends `:${string}?` ? CreateParams<Route[Path]> : {}) : never;
    export interface Config {
        fetch?: Omit<RequestInit, 'headers' | 'method'>;
        fetcher?: typeof fetch;
        headers?: MaybeArray<RequestInit['headers'] | ((path: string, options: RequestInit) => MaybePromise<RequestInit['headers'] | void>)>;
        onRequest?: MaybeArray<(path: string, options: RequestInit) => MaybePromise<RequestInit | void>>;
        onResponse?: MaybeArray<(response: Response) => MaybePromise<unknown>>;
        keepDomain?: boolean;
    }
    export type TreatyResponse<Res extends Record<number, unknown>> = {
        data: Res[Extract<keyof Res, SuccessCodeRange>] extends {
            [ELYSIA_FORM_DATA]: infer Data;
        } ? Data : Res[Extract<keyof Res, SuccessCodeRange>];
        error: null;
        response: Response;
        status: number;
        headers: ResponseInit['headers'];
    } | {
        data: null;
        error: Exclude<keyof Res, SuccessCodeRange> extends never ? {
            status: unknown;
            value: unknown;
        } : {
            [Status in keyof Res]: {
                status: Status;
                value: Res[Status] extends {
                    [ELYSIA_FORM_DATA]: infer Data;
                } ? Data : Res[Status];
            };
        }[Exclude<keyof Res, SuccessCodeRange>];
        response: Response;
        status: number;
        headers: ResponseInit['headers'];
    };
    export interface OnMessage<Data = unknown> extends MessageEvent {
        data: Data;
        rawData: MessageEvent['data'];
    }
    export type WSEvent<K extends keyof WebSocketEventMap, Data = unknown> = K extends 'message' ? OnMessage<Data> : WebSocketEventMap[K];
    type MaybeFunction<T> = T | ((...a: any) => T);
    type UnwrapMaybeFunction<T> = T extends (...a: any) => infer R ? R : T;
    type MaybePromise<T> = T | Promise<T>;
    export type Data<Response extends MaybeFunction<MaybePromise<Treaty.TreatyResponse<{}>>>> = NonNullable<Awaited<UnwrapMaybeFunction<Response>>['data']>;
    export type Error<Response extends MaybeFunction<MaybePromise<Treaty.TreatyResponse<{}>>>> = NonNullable<Awaited<UnwrapMaybeFunction<Response>>['error']>;
    export {  };
}

declare function streamResponse(response: Response): AsyncGenerator<Record<string, unknown>, void, any>;
declare const treaty: <const App extends Elysia<any, any, any, any, any, any, any>>(domain: string | App, config?: Treaty.Config) => Treaty.Create<App>;

export { Treaty, streamResponse, treaty };
